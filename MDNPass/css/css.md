#### CSS选择器
CSS选择器种类，  
1. HTML元素选择器  
   ```css
   h1{

   }
   ```
2. class类选择器  
   ```css
   .class{

   }
   ```
3. id选择器  
   ```css
   #id{

   }
   ```
4. 标签属性选择器,元素上某个属性的存在来选择  
   ```css
   a[title] {
    }
    /*
        元素属性的特定值来选择
    */ 
    a[href="https://example.com"]{
    
    }
   ```
5. 伪类与伪元素选择器
   ```css
   /*伪类选择器用来样式化一个元素的特定状态*/
    a:hover{

    }
    /*伪元素，选择一个元素某个部分，而不是这个元素全部*/
    p::first-line{

    }
   ```
6. 运算符
   ```css
   /*
    使用运算符选择article元素的初代子元素
   */ 
   article > p{

   }
   ```
#### CSS类选择器
用类选择器选择，使用了某一特定类的元素。  
```css
    h1.warning{
        
    }
```  
选择应用了多个类元素
```css
    .warn.err{

    }
```
#### CSS属性选择器
用于根据元素是否存在某个属性，或者某个特定属性值的选择器
```css
li[class]{
    /*
    选择使用了class属性的li
    */
}
li[class=""a]{
     /*
    选择使用了class属性,且class属性值为a的元素,但不会选择class属性值中有多个类的元素
    */
}
li[class~=a]{
     /*
    选择使用了class属性,且class属性值为a的元素,会选择class属性值中有多个类的元素
    */
}
/*[]中，属性值的具体值，可以按照^=匹配字符串开头，$=匹配字符串结尾,*=匹配至少出现过一次的字符串 */
/*[]闭合前添加i字符串告诉浏览器，以大小写不敏感的方式进行匹配 */
```
#### 伪类
伪类选择器用于选择处于特定状态的元素，比如当它们是这一类型元素的第一个元素时，或是当鼠标指针悬停在元素上方时。
```css
/**伪类是开头为':'的关键字 */
:pseudo-class-name{

}

p:first-child{

}
/**伪元素开头为'::'的关键字 */
::pseudo-element-name{

}

p::first-line{

}
```
#### 关系选择器
```css
/**用单个空格组合两个选择器，第二个选择器匹配的元素被选择，如果第二个选择器表示的元素有一个祖先，匹配第一个选择器。 */
body article{

}
/**直接子元素将会被匹配。如下选择器article直接子元素p将会被选择。 */
article > p{

}
/**邻接选择器，选择在继承关系上同级的元素旁边的元素,必须是旁边的 */
p + img{

}

/**
    通用兄弟选择器,选择一个元素的兄弟元素，即使不直接相邻
 */
 p ~ img{
     
 }
```
#### CSS创建小技巧
比较通用的元素设置使用元素选择器,一些特殊情况定义不同的类选择器进行修改。
#### CSS选择器优先级
选择器优先级分为 百（ID）、十(类)、个(元素)  
一个CSS选择器有id选择器则百位+1,有类型选择器十位+1,有元素选择器时个位+1。  
内联样式优先于所有普通样式。无论优先级如何。

#### CSS层叠层
1. 创建层叠层
>在css文件头部以@layer关键字创建层叠层。  
>@layer块代码可以创建匿名层叠层。  
>已@layer具名代码块规则可以创建具名层叠层，同时可以直接在其中声明样式代码。  
>重复声明@layer具名代码块可以向已创建的层叠层中添加新的样式代码。对于匿名@layer代码块，每重新声明一个就会增加一个匿名层叠层，而不是向其中添加样
>式
2. 继承，与控制继承
> 属性继承，指有些属性在父级设置完成之后会直接在其子元素及其后代中继承使用。
> CSS为控制继承提供了五个特殊的通用属性值
>```css
>p{
> color: inherit; /* 表示当前color继承父元素属性值 */
> color: initial; /* 表示当前color属性，使用其属性的初始值*/
> color: revert; /* 表示当前color属性，使用浏览器用户代理的默认样式，而不是默认值*/
> color: revert; /* 表示当前color属性，使用前一个层叠层指定的值*/
> color: unset; /*  表示当前color属性，使用自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样*/
>}
> p{
> all:unset; /* all 属性可以将上述的继承用属性值，应用于元素的几乎所有CSS属性。一般用以撤销样式。*/
>}
>```

3. 层叠的应用方式。
资源顺序
4. 

6. 层叠层的优先级排列。
上述代码创建了两个具名层和一个未命名层。假设这三个文件（A.css、 B.css 和 C.css）本身不包含任何额外的层。以下列表显示了在这些文件内外声明的样式将以从最低（1）优先权到最高（10）优先权进  行排序。  

firstLayer 普通样式（A.css）  
secondLayer 普通样式（B.css）  
未分层普通样式（C.css）  
内联普通样式  
动画样式  
未分层重要样式（C.css）  
secondLayer 重要样式（B.css）  
firstLayer 重要样式（A.css）  
内联重要样式  
过渡样式  
重要样式，即包含 !important 标志的属性值，优先于我们列表中前面提到的任何样式。它们的排序顺序与普通样式的顺序相反。在层外声明的任何重要样式的优先权都低于在层内声明的样式。在层中找到的重  要样式也按层的创建顺序进行排序。对于重要样式，最后创建的层具有最低的优先权，而首先创建的层在声明的层中具有最高的优先权。  
#### 盒模型
1. 区块盒子(block boxes)与行内盒子(inline boxes)
CSS中最常见的盒模型是区块盒子、行内盒子，类型区分了盒子在页面流中的行为方式和与其他盒子的关系。盒子有内部显示（inner display type）和外部显示（outer display type）两种类型。  

一个拥有 block 外部显示类型的盒子会表现出以下行为：  
### 外部显示类型

1. 一个拥有block外部显示类型的盒子会表现出一下行为:
盒子会产生换行。  
width 和 height 属性可以发挥作用。  
内边距、外边距和边框会将其他元素从当前盒子周围“推开”。  
如果未指定 width，方框将沿行向扩展，以填充其容器中的可用空间。在大多数情况下，盒子会变得与其容器一样宽，占据可用空间的 100%。  
具体类型的元素`<h1>`,`<p>`等  

2. 一个拥有 inline 外部显示类型的盒子会表现出以下行为：  

盒子不会产生换行。  
width 和 height 属性将不起作用。  
垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。  
水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。  
某些 HTML 元素，如 <a>、 <span>、 <em> 以及 <strong>，默认使用 inline 作为外部显示类型。  

更改元素的display属性为:block、inline会修改元素的外部显示类型
### 盒模型的各个部分
#### 标准盒模型
1. 内容盒子:显示内容的区域使用`inline-size`、`block-size`、`width`、`height`定义其大小
2. 内边距盒子：填充位于内容周围的空白处；使用 `padding` 和相关属性确定其大小。
3. 边框盒子：边框盒子包住内容和任何填充；使用 `border` 和相关属性确定其大小。
4. 外边距盒子：外边距是最外层，其包裹内容、内边距和边框，作为该盒子与其他元素之间的空白；使用 margin 和相关属性确定其大小。
#### 代替盒模型
在替代盒模型中，任何宽度都是页面上可见方框的宽度。内容区域的宽度是该宽度减去填充和边框的宽度（见下图）。无需将边框和内边距相加，即可获得盒子的实际大小。  
  
要为某个元素使用替代模型，可对其设置 `box-sizing: border-box`：  
```css
.box {
  box-sizing: border-box; /*将使得元素的盒模型变为代替盒模型，且以边框线为盒模型*/
}
```
#### 外边距
外边距是盒子周围一圈看不到的空间。它会把其他元素退推离盒子。外边距属性值可以为正也可以为负。在盒子一侧设置负值会导致盒子和页面上的其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。  
```css
p{
   margin-top:"";
   margin-right:"";
   margin-bottom:"";
   margin-left:"";
}
```
1. 外边距折叠
根据外边距相接触的两个元素是正边距还是负边距，结果会有所不同：  

两个正外边距将合并为一个外边距。其大小等于最大的单个外边距。  
两个负外边距会折叠，并使用最小（离零最远）的值。  
如果其中一个外边距为负值，其值将从总值中减去。  
#### 内边距
内边距位于边框和内容区域之间，用于将内容推离边框。与外边距不同，内边距不能为负数。任何应用于元素的背景都会显示在内边距后面。  

我们可以使用 padding 简写属性一次性控制元素所有边，或者每边单独使用等价的普通属性：  

padding-top  
padding-right  
padding-bottom  
padding-left  

#### 介于block和inline之间的外部表现形式
1. display:inline-block介于block和inline之间。它提供了介于 inline 和 block 之间的中间位置。如果不希望元素换行，但又希望它使用 width 和 height 值并避免出现上述重叠现象，请使用它。  
一个元素使用 display: inline-block，实现我们需要的块级的部分效果：  

设置 width 和height 属性会生效。  
padding、margin 和 border 会推开其他元素。  